# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LD9YnzOnf7e2NLc4v8Mwf8rKxlbemW4h
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

def modeloLineal(w,b,x):  # modelo es y = w x +b donfde de forma automatica se obtiene w y b
    return w*x+b

def error(yData,yModel): # corresponde al erros cuadratico medio ECM donde compara valor de los datas y predicho por el modelo conforme se ajusta
    data = pd.read_csv('linealRel.csv', sep=";")
    N = len(data) # N = yData.shape[0]
    error = np.sum((yData-yModel  )**2) / N
    return error

def dataAdq():
    data = pd.read_csv('linealRel.csv', sep=";")
    print(data)

    data.plot.scatter(x='x', y='y')
    plt.xlabel('x')
    plt.ylabel('y')
    plt.show()
    
    # almacenar en "arrays"
    x = data['x'].values
    y = data['y'].values
    
    return x,y

#___________________-Aprendizaje______________________________

def gradDesc(w_, b_, alpha, x, y):  # minimiza el error cuadratico medio ECM =  es igual a la funcion de coste, encontrar un minimo en la funcion
    # se definen  taza de aprendizaje alpha ... tamano del paso
    N = x.shape[0]      # Cantidad de datos

    # Gradientes: derivadas de la funci칩n de error con respecto
    # a los par치metros "w" y "b"
    dw = -(2/N) * np.sum(x*(y-(w_*x+b_)))
    db = -(2/N) * np.sum(y-(w_*x+b_))

    # Actualizar los pesos usando la f칩rmula del gradiente descendente
    w = w_ - alpha * dw
    b = b_ - alpha * db

    return w, b





def training(iterations,alpha):
    x , y = dataAdq()
    # print(y)
    # proceso de aprendizaje
    np.random.seed(2)           # Para reproducibilidad del entrenamiento
    w = np.random.randn(1)[0]
    b = np.random.randn(1)[0]
    
    errores = np.zeros((iterations,1)) # almacenar valores corespondientes al error
    
    for i in range(iterations):
        [w, b] = gradDesc(w,b,alpha,x,y)   # Actualizar valor de los pesos usando el gradiente descendente u
                                         # ajusta el ecm

        yModel = modeloLineal(w,b,x)  # Calcular el valor de la predicci칩n
       
        errores[i] = error(y ,yModel)       # valor del ECM error ....

        # Imprimir resultados cada 1000 epochs
        if (i+1) % 1000 == 0:
            print("Epoch {}".format(i+1))
            print("    w: {:.1f}".format(w), " b: {:.1f}".format(b)) # valor de w y b
            print("    error: {}".format(errores[i]))                  # error correspondiente
            print("_______________________________")

a = 0.0004             # learning rate
iterations = 10000               # iteraciones            
training(iterations,a)



# https://datagy.io/pandas-select-columns/



# regresion Lineal y Minimos Cuadrados ordinarios

# se hace proceso para minimizar funcion de coste para ajustar l linea determinada

import numpy as np
import scipy as sc

import matplotlib.pyplot as plt

from sklearn import preprocessing, svm 
from sklearn.model_selection import train_test_split 
from sklearn.linear_model import LinearRegression 

from sklearn import datasets, linear_model
from sklearn.metrics import mean_squared_error, r2_score

# Load the diabetes dataset
diabetes_X, diabetes_Y = datasets.load_diabetes( return_X_y = True)

# Use only one feature
diabetes_X = diabetes_X[:, np.newaxis, 2]   # matriz X le corresponden , Y es le comportamiento a modelar ,w es e vector de parametros
#diabetes_X = diabetes_X.T

diabetes_X = np.array(diabetes_X) ; diabetes_Y= np.array(diabetes_y)

print(diabetes_X)
#anade columna de 1 para asociar un w de temirno independiente
#diabetes_X = np.array([,diabetes_X]).T
#diabetes_X[ [diabetes_X[1]] ,  diabetes_X]  

print(diabetes_X)
plt.scatter(diabetes_X,diabetes_Y, alpha= 0.5)  # alpha es transparencia


# error cuadratico medio... (Xt * X)-1 Xt Y

beta = np.linalg.inv(diabetes_X.T @ diabetes_X )@ diabetes_X.T @diabetes_Y 
# es una operacion matricial la multiplicaiocn punto punto seria con @... matriz de parametros que minimiza el error cuadratico medio

print(beta)

#xa = 0.01 , xb = 0.15
#xxa = beta[0]+ beta[1]* xa] ; xxb = beta[0]+ beta[1]* xb]
#plt.plot([xa,xb], [xxa, xxb] )
plt.show()

# https://scikit-learn.org/stable/auto_examples/linear_model/plot_ols.html
# https://stackoverflow.com/questions/8486294/how-to-add-an-extra-column-to-a-numpy-array



import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

data = pd.read_csv('linealRel.csv', sep=";")

x = data['x'].values
y = data['y'].values

N = len(x)
print(N)
m = []
b = []

for i in range(N):
  #print(i , y[i] , i+1)

  if i < N-1 :
    deltaY = y[i+1] - y[i]
    deltaX = x[i+1] - x[i]
    m_i = deltaY / deltaX
    
    b_i = y[i] - m_i * x[i]
  
    m.append(m_i)
    b.append(b_i)

  if i+1 == N:
    break



